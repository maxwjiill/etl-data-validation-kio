% Пример статьи для журнала КИО
\documentclass[intlimits,twoside,a4paper,11pt]{article}

% текст статьи рекомендуется писать в кодировке utf-8
\usepackage[utf8]{inputenc}

% Подключение пакета с шаблоном журнала.
% Необзятальная опция eqsecnum указывает, что в каждом разделе формулы нумеруются заново.
% Опция authorsinfo заставляет выводиться информацию об авторе
\usepackage[eqsecnum,authorsinfo]{kioj4}
% Здесь можно подключить свои пакеты. Некоторые пакеты работают только если их подключить перед предыдущей строкой \usepackage[eqsecnum]{kioj4}
% \usepackage[•]{•}
\usepackage{array}

% Указываем номер страницы, с которой начинается статья, можно не указывать, будет нумероваться с первой.
\setcounter{page}{41}

%рубрика в журнале, обычно не известна при подаче статьи, поэтому не указываем
\journalsectionnoimage{informatics}
%\journalsection{informatics}
%\journalsection{information-systems}
%\journalsection{software-engineering}
%\journalsection{computer-in-education}
%\journalsection{popular-science-articles}
%\journalsection{programming-practice}
%\journalsection{editorial-column}
%\journalsection{specialists-training-new-teaching-methods}
%\journalsection{specialists-training-training-programs}
%\journalsection{specialists-training-professional-standards}
%\journalsection{open-problems-for-young-scientists}
%\journalsection{empty}

%указывам год, номер выпуска неизвестен, поэтмоу ставим прочерк, указываем edu, что означает журнал "компьютерные инструменты в образовании".
\issue{2015}{-}{edu}
% Указываем УДК для статьи
\udknumber{621.320}
% Указываем DOI для статьи, можно не указывать
\doinumber{10.1000/182}


\usepackage{amsmath,amssymb,amstext} %конфликтует с \iint
\usepackage{graphicx,multirow,makecell} 
%\usepackage{nicematrix} % просто, но не работает в данном шаблоне



%%algorithms

\usepackage[linesnumbered,noend]{algorithm2e}%for a compact view paste ,noend

%boxed,
%user commands
% Перевод плагина
\SetKwInput{KwData}{Исходные параметры}
\SetKwInput{KwResult}{Результат}
\SetKwInput{KwIn}{Вход}
\SetKwInput{KwOut}{Выход}
\SetKwIF{If}{ElseIf}{Else}{если}{тогда}{иначе если}{иначе}{конец условия}
\SetKwFor{While}{до тех пор, пока}{выполнять}{конец цикла}
%\SetKw{KwTo}{от} % ТУТ ВИДИМО ОПИСКА - пока ? до тех пор, пока? до?
\SetKw{KwTo}{до }
\SetKw{KwRet}{возвратить}
\SetKw{Return}{возвратить}
\SetKwBlock{Begin}{начало блока}{конец блока}
\SetKwSwitch{Switch}{Case}{Other}{Проверить значение}{и выполнить}{вариант}{в противном случае}{конец варианта}{конец проверки значений}
\SetKwFor{For}{цикл с}{выполнять}{конец цикла}
\SetKwFor{ForEach}{для каждого}{выполнять}{конец цикла}
\SetKwRepeat{Repeat}{повторять}{до тех пор, пока}
\SetAlgorithmName{Алгоритм}{алгоритм}{Список алгоритмов}
\SetAlgoCaptionSeparator{.}
\SetAlgorithmName{Fig.}{} %last arg is the title of listing table


\SetNlSkip{0em}
\SetNlSty{normalsize}{\hphantom{0}}{.}%\hspace*{5mm} не работают пробелы
\SetAlgoNlRelativeSize{-1}
%% https://tex.stackexchange.com/questions/153646/algorithm2e-disabling-line-numbers-for-specific-lines
\let\oldnl\nl% Store \nl in \oldnl
\newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line

%%% RUSSIAN

%% GOST package
% https://mirror.macomnet.net/pub/CTAN/biblio/bibtex/contrib/gost/doc/gost.pdf

%\bibliographystyle{utf8gost705u}
%\bibliographystyle{utf8gost71u}
%\bibliographystyle{utf8gost71s}
%\bibliographystyle{utf8gost780u}

%\bibliography{database}


%% BIBLATEX-GOST
%\usepackage[%
%citestyle=gost-numeric,
%bibstyle=gost-footnote,
%language=english,
%autolang=other]{biblatex}
%\addbibresource{damdid2023.bib}



%Указываем название статьи в обычном регистре в квадратных скобках, потом заглавными буквами в фигурных скобках. Второй вариант будет использоваться только в заголовке, первый вариант будет использоваться во всех других местах, в частности, при цитировании.
\title[Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования]{МЕТОД КОГГЕРА И Ю: ОТКРЫТАЯ КОМПЬЮТЕРНАЯ РЕАЛИЗАЦИЯ И РЕШЕНИЕ ЗАДАЧ РАНЖИРОВАНИЯ} %https://ru.texthandler.com/text-tools/letter-case-converter/

%Информация об авторах. Каждый автор указывается отдельно с помощью трех инструкций \authorI, \authorIaddr, \authorIemail. Номера авторов могут быть I, II, III, IV, V.
%Один из авторов должен быть основным получателем корреспонденции, в этом случае вместо команды \author*email нужно использовать команду \author*emailEnvelope
%в команде \author* указывается сначала имя автора с инициалами в квадратных скобках, потом указывается полное имя автора. Полное имя используется только при выводе расширенной информации об авторе.
%в команде \affil указывается через запятую список организаций, которые представляет автор. Сами организации указываются ниже командой \affiliation.
%\authorIaddr и \affilitaion различаются тем, что первое является кратким расском об авторе, в отличие от второго, где указывается только организация.
\authorI[Пархоменко В.~А.\affil{1}]{Пархоменко Владимир Андреевич}
\authorIpos{старший преподаватель} % Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого
\authorIinfo{старший преподаватель Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого}%
\authorIemailEnvelope{vladimir.parkhomenko@spbstu.ru}
\authorIorcid{orcid.org/0000-0001-7757-377X}


\authorII[Лазаренко А.~А.\affil{1}]{Лазаренко Артем Андреевич}
\authorIIpos{магистр}% Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого
\authorIIinfo{магистр Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого}
\authorIIemail{lazarenko2.aa@edu.spbstu.ru}
\authorIIorcid{orcid.org/0009-0005-1029-8095}


\authorIII[Щукин А.~В.\affil{1}]{Щукин Александр Валентинович}
\authorIIIpos{к.т.н., доцент}% Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого
\authorIIIinfo{к.т.н., доцент Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого}
\authorIIIemail{alexander.schukin@spbstu.ru}
\authorIIIorcid{orcid.org/0000-0002-9534-824X}

\affiliation{1}{СПбПУ, Санкт-Петербургский политехнический университет Петра Великого, ул. Политехническая, дом 29, Санкт-Петербург, 195251, Россия}



\begin{document}
    \maketitle

    \begin{abstract}
        Рассмотрен метод Коггера и Ю для вычисления весов и ранжирования альтернатив. На основе этого метода парных сравнений разработана система поддержки принятия решений с открытым исходным кодом.  Представлена архитектура разработанного приложения, проведены модульные тесты, включая примеры из публикаций и специально сгенерированные случаи. Пример В.В. Подиновского, иллюстрирующий некорректность метода анализа иерархий, показал, с нашей точки зрения, приемлемый результат методом Коггера и Ю. Эксперимент подтвердился и на новой оригинальной задаче, показывая близость результатов метода Коггера и Ю и теории важности критериев. Решена задача ранжирования алгоритмов генерации уровней для компьютерных игр в двухмерном пространстве. 
        \keywords многокритериальные задачи принятия решений, парные сравнения, метод Коггера и Ю, теория важности критериев, DASS, СВИРЬ.
        %Команда \autocitationexample автоматически генерирует пример цитирования статьи, либо можно самостоятельно написать цитирование с помощью команды \citationexample
        \autocitationexample
        %\citationexample Андреев А.~А., Борисов Б.~Б. Шаблон статьи для журнала КИО. Нигде не опубликовано
        \acknowledgements Авторы статьи благодарны коллективу разработчиков СППР СВИРЬ под руководством профессора С.В. Микони за предоставление возможности решения задач в системе, а также коллективу разработчиков СППР DASS под руководством профессора В.В. Подиновского за размещение инсталлятора системы в свободном доступе.
    \end{abstract}

    \section{ВВЕДЕНИЕ}
%    Заголовки всех разделов пишутся заглавными буквами. Подразделы и меньше~--- в обычном регистре.

В реальных задачах ранжирования альтернатив трудно обойтись непосредственным сущностным сравнением или сравнением по одному критерию, и тогда прибегают решению многокритериальной задачи. 
В работе рассмотрены методы индивидуального принятия решений. Оригинальные постановки по методам, базирующимся на парных сравнениях,  на основе log-Чебышевского метода аппроксимации, модификаций методов парных сравнений приведены в \cite{Krivulin2015} и~\cite{Mikoni2022}, соответственно. Обзоры по индивидуальным методам принятия решений с подробным анализом их работы можно найти, например, в \cite{Mikoni2022,Podinovskiy2022,Petrovskiy2009,Chern2012}.

В работе рассмотрен метод Коггера и Ю~\cite{CoggerYu1985}, являющийся одной из модификаций метода аналитической иерархии Саати~\cite{Saaty1977}. Оба метода направлены на ранжирование альтернатив на основе матриц парных сравнений. Если реализаций метода аналитической иерархии довольно много, например, бесплатная, многофункциональная СППР Superdecisions~\cite{Superdecisions},  СППР с открытым исходным кодом~\cite{Salimgareev2023}, то открытых реализаций метода Коггера и Ю найти не удалось.

Целью работы является изучение метода Коггера и Ю для нахождения приоритетов (весов) альтернатив, их последующего ранжирования, а также создание системы поддержки ранжирования альтернатив на базе этого метода.


Разработано приложение с открытым исходным кодом~\cite{ParkhLaz2024}. Эксперименты показали, что на примере, обосновывающем некорректность метода аналитической иерархии~\cite{Podinovskiy2011}, получен более корректный результат, близкий к результату теории важности критериев.


Далее в 1 разделе изложена общая постановка задачи ранжирования объектов по нескольким признакам.  В разделе 2 подробно описывается метод Коггера и Ю. В разделе 3 представлено проектирование системы ранжирования на основе метода Коггера и Ю. В разделе 4 представлены шаги алгоритма с псевдокодом и иллюстративными примерами расчета. В разделе 5 описываются классы системы ранжирования на основе метода Коггера и Ю. В разделе 6 описывается модульное тестирование системы. В разделе 7 описывается ручное тестирование системы, включая действия по установке приложения. 

В разделе 8 сравниваются решения метода Коггера и Ю с решениями метода анализа иерархий, метода взвешенных геометрических средних, а также log-Чебышевского метода аппроксимации~\cite{Krivulin2024}. В разделе 9 представлено сравнение решений метода Коггера и Ю с методом анализа иерархий и теорией важности критериев~\cite{Podinovskiy2022,Podinovskiy2011}. В разделе 10 представлено решение задачи ранжирования алгоритмов генерации уровней для компьютерных игр в двухмерном пространстве методом Коггера и Ю, рассчитанным в разработанной системе, методом аналитической иерархии, рассчитанным в СППР СВИРЬ~\cite{Svir,Mikoni2001,Mikoni2009}, а также методом теории важности критериев, рассчитанным в СППР DASS~\cite{DASS,Podinovskiy2008,Podinovskiy2007}. 

\section{ПРОБЛЕМА РАНЖИРОВАНИЯ ОБЪЕКТОВ ПО ВАЖНОСТИ}

Пусть дано конечное множество объектов (признаков или альтернатив) $G = \left\{ g_{1},g_{2},\ldots,g_{n} \right\}$, и необходимо построить вектор $w = \left( w_{1},w_{2},\ldots,w_{n} \right)$ с неотрицательными компонентами \(w_{i}\) такими, что \(\sum_{i = 1}^{n}{w_{i} = 1}\).

Числа \(w_{i}\) можно интерпретировать, как весовые коэффициенты, определяющие важность объектов \(g_{i}\). Основным объектом исследования
в рассматриваемом методе является матрица парных сравнений. Элементы данной матрицы интерпретируются, как значения коэффициента превосходства
одного объекта над другим. Если получается число больше единицы, то
первый объект превосходит второй объект.

Предполагается, что лицо, принимающее решения, (далее ---~ЛПР) имеет возможность отвечать на вопросы типа <<Во сколько раз объект \(g_{i}\) превосходит объект \(g_{j}\) по важности?».

Коэффициенты МПС могут выбираться из различных шкал, например, метод Саати использует следующую бальную шкалу: \(\left\{ \frac{1}{9},\frac{1}{8},\frac{1}{7},\frac{1}{6},\frac{1}{5},\frac{1}{4},\frac{1}{3},\frac{1}{2},1,2,3,4,5,6,7,8,9 \right\}\).

Для упрощения работы пользователя можно интерпретировать значения шкалы
с помощью целых чисел или вербальных оценок.

\section{ОПИСАНИЕ МЕТОДА КОГГЕРА И Ю}


В отличие от метода Саати~\cite{Saaty1977}, в методе Коггера и Ю~\cite{CoggerYu1985}
используется треугольная матрица парных сравнений (отсутствует сторона с
подкреплением ответов лица, принимающего решение, то есть значения ниже
главной диагонали). Сначала находится диагональная делящая матрица:
%(формула~\ref{eq:matrix-diagonal}).

\begin{equation*}\label{eq:matrix-diagonal}
	D_{n \times n} = \begin{pmatrix}
		n & 0 & 0 & 0 \\
		0 & n - 1 & 0 & 0 \\
		0 & 0 & \ldots & 0 \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix}.
\end{equation*}


В последствии данная матрица обращается и в результате получается
матрица \(D_{n \times n}^{- 1}\), в которой ненулевые $i$-ые элементы
образуются делением единицы на значение из ячейки исходной матрицы
\(D_{n \times n}^{}\) с тем же самым $i$-ым индексом. В методе Коггера и Ю
могут использоваться матрицы парных сравнений кратности предпочтения, которая имеет следующий вид:
%Вид матрицы кратности предпочтений приведен в~\ref{eq:matrix-KP}.

\begin{equation*}\label{eq:matrix-KP}
	S_{3 \times 3} = \begin{pmatrix}
		1 & s_{12} & s_{13} \\
		0 & 1 & s_{23} \\
		0 & 0 & 1 \\
	\end{pmatrix}.
\end{equation*}

В пособии~\cite{Chern2012} и работе~\cite{Chern2019} предлагают опрашивать ЛПР \(n - 1\) раз
по шкале кратности предпочтений (таблица~\ref{table-scales-KP}).

%https://tex.stackexchange.com/questions/201696/how-to-rotate-text-in-a-cell-and-center-it-vertically-and-horizontally
%\makecell[t OR c] is ok!
    \begin{table}[H]
	        \centering
	        \caption{Шкалы предпочтений с различными степенями [1]}
	        \label{table-scales-KP}
	        \small
%	        \begin{tabular}{llllllllll}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
%	        \begin{tabular}{|p{5cm}|c|}
		            \hline
		            \centering
	\rotatebox{0}{\makecell[t]{\centering$p/i$}} & \rotatebox{90}{\makecell[t]{Абсолютное \\ превосходство}} & \rotatebox{90}{\makecell[t]{Очень сильное \\  превосходство}} & \rotatebox{90}{\makecell[t]{Сильное \\  превосходство}} & \rotatebox{90}{\makecell[t]{Слабое \\  превосходство}} & \rotatebox{90}{\makecell[t]{Равнозначность}} & \rotatebox{90}{\makecell[t]{Слабая  уступка}} & \rotatebox{90}{\makecell[t]{Сильная  уступка \hspace*{1pt}}} & \rotatebox{90}{\makecell[t]{Очень сильная  \\ уступка}} & \rotatebox{90}{\makecell[t]{Абсолютная  \\ уступка}} \\ 		            \hline
	1,5 & 5,0625                     & 3,375                         & 2,25                    & 1,5                    & 1              & 0,(6)          & 0,(4)           & 0,(296)                 & 0,(1975)             \\ 		            \hline
	2   & 16                         & 8                             & 4                       & 2                      & 1              & 0,5            & 0,25            & 0,125                   & 0,0625               \\ 		            \hline
	3   & 81                         & 27                            & 9                       & 3                      & 1              & 0,(3)          & 0,(1)           & 0,0(370)                & 0,(0..9)             \\ 
		            \hline
		        \end{tabular}
	    \end{table}


Это необходимо для того, чтобы избежать противоречий в показаниях ЛПР.
Остальные показатели рассчитываются с помощью сверхтранзитивности:
%(формула~\ref{eq:trasitivity-super}).

\begin{equation}\label{eq:trasitivity-super}
	\begin{matrix}
	s_{ik} = s_{ij} \cdot s_{jk}.
\end{matrix}\end{equation}

Пусть \(s_{12},\ s_{23}\ \)в формуле~\ref{eq:trasitivity-super} --- это ответы ЛПР, тогда
\(s_{13}\) выводится автоматически, по замыканию. Оценки всегда
располагаются выше главной диагонали. Для избежания ошибок во время
работы алгоритма матрица парных сравнений заполняется снизу вверх.
Следующим шагом идет подсчет суммы каждой строки матрицы \(D^{- 1}S\)
для создания вектора сумм: %(формула~\ref{eq:vector-summ}).

\begin{equation*}\label{eq:vector-summ}
	a = \begin{bmatrix}
			\sum_{i = 1}^{n}s_{1i} \\
			\sum_{i = 2}^{n}s_{2i} \\
			\ldots \\
			\sum_{i = j}^{n}s_{ji} \\
			1 %\\
	\end{bmatrix}.
\end{equation*}

В результате с помощью двух матриц и одного вектора можно найти вес
каждого объекта: %(формула~\ref{eq:alternatives-scalars}) [2].

\begin{equation}\label{eq:alternatives-scalars}
	D^{- 1}Sa = w.
\end{equation}

Вектор весов \(w\) имеет такую же размерность, как и вектор сумм \(a\).
Данный вектор все еще не готов к использованию, так как его необходимо
нормализовать, полагая \(\sum_{i = 1}^{n}w_{i}~=~1\). Для достижения
такого результата можно рассмотреть вспомогательные формулы~\ref{eq:omega-1} и~\ref{eq:omega-2}, где \(|w|\) в во второй формуле --- мощность множества
(размер вектора), а значение <<2>> означает, что для нормализации необходимо минимум 2
числа (при меньшем количестве эта операция не имеет смысла).

\begin{equation}\label{eq:omega-1}
	\omega_{i} = \frac{w_{i}}{\sum_{j = 1}^{n}w_{j}}
\end{equation}

\begin{equation}\label{eq:omega-2}
	\omega_{i} = 1 - \frac{w_{i}}{\sum_{j = 1}^{n}w_{j}} - \frac{|w| - 2}{|w|}
\end{equation}

Формулы~\ref{eq:omega-1} и~\ref{eq:omega-2} используются, когда необходимо нормализовать
значения, подлежащие максимизации (чем больше, тем лучше) или минимизации
(чем меньше, тем лучше), соответственно. 

Когда веса признаков \emph{w} и веса альтернатив \(\omega_{i}\) по
каждому признаку \emph{i} рассчитаны, можно оценить альтернативы c помощью
%(формула~\ref{eq:alternatives-scalar-evaluation}), 

\begin{equation}\label{eq:alternatives-scalar-evaluation}
	evaluation = \omega w,
\end{equation}
где \(\omega\) -- матрица весов альтернатив, составленная
из последовательных \(\omega_{i}\).


Далее спроектируем систему, позволяющую ранжировать альтернативы на
основе метода Коггера и Ю.


\section{ПРОЕКТИРОВАНИЕ АРХИТЕКТУРЫ СИСТЕМЫ ПОДДЕРЖКИ РАНЖИРОВАНИЯ АЛЬТЕРНАТИВ НА ОСНОВЕ МЕТОДА КОГГЕРА И Ю}


На рис.~\ref{fig:Cogger-system-archi} представлена общая схема работы программы в нотации
Archimate~\cite{Archimate}.

    \begin{figure}[htb]
	        \centering
\includegraphics[width=\textwidth,keepaspectratio]{vertopal_e4e57282f7da49f4b12d2e1664ac28e6/media/image1.png}\caption{Схема работы программы c реализацией метода Коггера и Ю}\label{fig:Cogger-system-archi}
\end{figure}


При запуске программы пользователь попадает в основной цикл (Main loop),
в котором он может выбирать действия с помощью ввода с клавиатуры.

В настройках (Settings) пользователь может выбрать отображение
дополнительной информации (Additional info) для просмотра МПС, способ
оценивания (для сравнения реализован метод простого выбора из пособия~\cite{Chern2012} для сравнения с методом Коггера и Ю), основание предпочтения
(Preference base, таблица~\ref{table-scales-KP}).

Диалоговая система задает вопросы ЛПР и по его ответам оценивает
приоритет альтернатив.

Для реализации указанного в подразделе функционала выбран язык общего
назначения Java. Систему решено реализовать в виде консольного
приложения. Алгоритмическое проектирование метода Коггера и Ю
представлено в следующем разделе.

\section{МЕТОД КОГГЕРА И Ю НА АЛГОРИТМИЧЕСКОМ УРОВНЕ}


После того, как пользователь импортировал таблицу csv или txt формата,
ему задают вопросы о значимости признаков по следующему алгоритму:

\nonl
\newcommand{\myMatrixKP}{%
	\begin{algorithm*}[H]
		%\SetAlgoNoLine
		%\LinesNumbered % работает только глобально
		%\DontPrintSemicolon
%		\SetKwFunction{algo}{GenKP}%\SetKwFunction{proc}{proc}
		\SetKwProg{myalg}{Алгоритм формирования матрицы значимости признаков}{}{}%%{Algorithm}{}{}
		\myalg{}{%begin %% {\algo{}}
			\KwIn{массив признаков таблицы $M$.}
			\KwOut{матрица парных сравнений $S$.}
			\For{$i\leftarrow 0$ \KwTo $i\leq |M|,$}{ 
				\For{$j\leftarrow i$ \KwTo $j\geq 0$,}{ 
					\If{$j==i$}
							{$s_{ji}\leftarrow 1$\;}
					\Else{ 
						\If{$j==(i-1)$}
						{$buff\leftarrow$ ввод целого числа\;
						$s_{ji}\leftarrow p^{-buff+5}$\; %TODO check
						}
						\Else{ 
						$s_{ji} \leftarrow  s_{j,i-1}\cdot s_{j+1,i}$\;
						}
					}
				$j \leftarrow j-1$\;						
				}
				$i \leftarrow i+1$\;			
			}
		}%%end				
		
\end{algorithm*}}

%\begin{figure}[t!]
%	\myAllNIAGARA
%	\caption{Главный алгоритм NIAGARA-2}\label{alg:NIAGARA-main}
%\end{figure}
%
%
\myMatrixKP


С помощью данного фрагмента кода в матрице задаются значения признаков:
на диагонали 1, по соседству выше введенные пользователем значения,
причем \(p^{- x + 5}\) необходимо для приведения ответа к шкале
предпочтений, остальные значения вычисляются транзитивно.

Рассмотрим пример: пользователь ввел для таблицы с четырьмя признаками
ответы \{3, 5, 7\}, основание шкалы превосходства \(p = 2\), тогда
матрица парных сравнений строится следующим образом:
\begin{equation*}\label{eq:example-matrices}
	\begin{pmatrix}
		1 & - & - & - \\
		0 & 1 & - & - \\
		0 & 0 & 1 & - \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix} \rightarrow 
	\begin{pmatrix}
		1 & 2^{- 3 + 5} & - & - \\
		0 & 1 & 2^{- 5 + 5} & - \\
		0 & 0 & 1 & 2^{- 7 + 5} \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix} \rightarrow 
	\begin{pmatrix}
		1 & 4 & 4 & 1 \\
		0 & 1 & 1 & 0,25 \\
		0 & 0 & 1 & 0,25 \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix}.\ \
\end{equation*}

Далее происходит умножение делящей матрицы \(D^{- 1}\) на матрицу парных
сравнений S. Это можно реализовать с помощью деления в следующем алгоритме:

\nonl
\newcommand{\myMatrixDS}{%
	\begin{algorithm*}[H]
		%\SetAlgoNoLine
		%\LinesNumbered % работает только глобально
		%\DontPrintSemicolon
		%		\SetKwFunction{algo}{GenKP}%\SetKwFunction{proc}{proc}
		\SetKwProg{myalg}{Алгоритм произведения делящей матрицы на матрицу парных сравнений}{}{}%%{Algorithm}{}{}
		\myalg{}{%begin %% {\algo{}}
			\KwIn{матрица парных сравнений $S$.}
			\KwOut{матрица парных сравнений $D^{- 1}S$.}
			\For{$i\leftarrow 0$ \KwTo $i < S.rows,$}{ 
				\For{$j\leftarrow i$ \KwTo $j < S.cols$,}{ 
					$s_{ij} \leftarrow \frac{s_{ij}}{S.rows-1}$\;
					$j \leftarrow j+1$\;						
				}
				$i \leftarrow i+1$\;			
			}
		}%%end				
		
\end{algorithm*}}

%\begin{figure}[t!]
%	\myAllNIAGARA
%	\caption{Главный алгоритм NIAGARA-2}\label{alg:NIAGARA-main}
%\end{figure}
%
%
\myMatrixDS



В контексте рассматриваемого примера происходит деление каждой строки матрицы:
%
\begin{equation*}\label{}
%\begin{matrix}
	\left( \begin{matrix}
		1 & 4 & 4 & 1 \\
		0 & 1 & 1 & 0,25 \\
		0 & 0 & 1 & 0,25 \\
		0 & 0 & 0 & 1 \\
	\end{matrix} \middle| \begin{matrix}
		:\ 4 \\
		:3 \\
		:2 \\
		:1 \\
	\end{matrix} \right) \rightarrow \begin{pmatrix}
		0,25 & 1 & 1 & 0,25 \\
		0 & 0,33 & 0,33 & 0,08 \\
		0 & 0 & 0,5 & 0,13 \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix}.
\end{equation*}

После этого рассчитывается сумма каждой строки и превращается в вектор следующим образом:



\nonl
\newcommand{\myVectorA}{%
	\begin{algorithm*}[H]
		%\SetAlgoNoLine
		%\LinesNumbered % работает только глобально
		%\DontPrintSemicolon
		%		\SetKwFunction{algo}{GenKP}%\SetKwFunction{proc}{proc}
		\SetKwProg{myalg}{Алгоритм вычисления вектора сумм $a$}{}{}%%{Algorithm}{}{}
		\myalg{}{%begin %% {\algo{}}
			\KwIn{матрица парных сравнений $D^{- 1}S$.}
			\KwOut{вектор сумм $a$.}
			\For{$i\leftarrow 0$ \KwTo $i < DS.rows,$}{ 
				\For{$j\leftarrow i$ \KwTo $j < DS.cols$,}{ 
					$a_{i} \leftarrow a_{i} + s_{ij}$\;
					$j \leftarrow j+1$\;						
				}
				$i \leftarrow i+1$\;			
			}
		}%%end				
		
\end{algorithm*}}

%\begin{figure}[t!]
%	\myAllNIAGARA
%	\caption{Главный алгоритм NIAGARA-2}\label{alg:NIAGARA-main}
%\end{figure}
%
%
\myVectorA


Для рассматриваемого случая расчет вектора сумм представлен в
преобразовании:

\begin{equation*}\label{}
%\begin{matrix}
	\begin{pmatrix}
		0,25 & 1 & 1 & 0,25 \\
		0 & 0,33 & 0,33 & 0,08 \\
		0 & 0 & 0,5 & 0,13 \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix} \rightarrow \begin{pmatrix}
		2,5 \\
		0,74 \\
		0,63 \\
		1 \\
	\end{pmatrix}.
%\end{matrix}
\end{equation*}

После этого матрица \(D^{- 1}S\) умножается на вектор \emph{a}, после
чего получаются весовые коэффициенты \emph{w}, в контексте примера следующим образом:

\begin{equation*}\label{}
%\begin{matrix}
	\begin{pmatrix}
		0,25 & 1 & 1 & 0,25 \\
		0 & 0,33 & 0,33 & 0,08 \\
		0 & 0 & 0,5 & 0,13 \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix} \times \begin{pmatrix}
		2,5 \\
		0,74 \\
		0,63 \\
		1 \\
	\end{pmatrix} = \begin{pmatrix}
		2,245 \\
		0,532 \\
		0,445 \\
		1 \\
	\end{pmatrix}.
%\end{matrix}
\end{equation*}

После этого веса проходят нормализацию. Процесс нормализации представлен следующим образом:
%Рис. 1.4 Нормализация вектора весов


\nonl
\newcommand{\myVectorW}{%
	\begin{algorithm*}[H]
		%\SetAlgoNoLine
		%\LinesNumbered % работает только глобально
		%\DontPrintSemicolon
		%		\SetKwFunction{algo}{GenKP}%\SetKwFunction{proc}{proc}
		\SetKwProg{myalg}{Алгоритм нормализации вектора весов}{}{}%%{Algorithm}{}{}
		\myalg{}{%begin %% {\algo{}}
			\KwIn{вектор весов $w$.}
			\KwOut{нормализованный вектор весов $\omega$.}
			\For{$i\leftarrow 0$ \KwTo $i < |w|,$}{
				$sum \leftarrow sum + w_i$\;
				$i \leftarrow i+1$\;			
			}
			\For{$i\leftarrow 0$ \KwTo $i < |w|,$}{
				$\omega_i \leftarrow sum + w_i$\;
				$i \leftarrow i+1$\;			
			}
		}%%end				
		
\end{algorithm*}}

%\begin{figure}[t!]
%	\myAllNIAGARA
%	\caption{Главный алгоритм NIAGARA-2}\label{alg:NIAGARA-main}
%\end{figure}
%
%
\myVectorW




В рассматриваемом примере, получение нормализованного вектора весов
признаков представлено преобразованием

\begin{equation*}\label{}
%\begin{matrix}
	\begin{pmatrix}
		2,245 \\
		0,532 \\
		0,445 \\
		1 \\
	\end{pmatrix}\  \rightarrow \begin{pmatrix}
		0,53 \\
		0,13 \\
		0,1 \\
		0,24 
	\end{pmatrix}.
%\end{matrix}
\end{equation*}

Аналогичным образом рассчитываются веса альтернатив по каждому признаку.
Однако стоит учитывать, что при импорте таблиц значения признаков могут
быть заданы не по транзитивной шкале. В таком случае сверхтранзитивная
связь будет выполняться только для каждых трех элементов. Тогда можно
использовать алгоритм, отраженный далее:
%
%Рис. 1.5 Создание МПС при отсутствии транзитивности

\nonl
\newcommand{\myPWMwithoutConc}{%
	\begin{algorithm*}[H]
		%\SetAlgoNoLine
		%\LinesNumbered % работает только глобально
		%\DontPrintSemicolon
		%		\SetKwFunction{algo}{GenKP}%\SetKwFunction{proc}{proc}
		\SetKwProg{myalg}{Алгоритм создания МПС при отсутствии транзитивности}{}{}%%{Algorithm}{}{}
		\myalg{}{%begin %% {\algo{}}
			\KwIn{массив значений признака $m_k$.}
			\KwOut{матрица парных сравнений $S_k$ по признаку $m_k$.}
			\For{$i\leftarrow 0$ \KwTo $i < |m_k|,$}{ 
				\For{$j\leftarrow i$ \KwTo $j < |m_k|$,}{ 
					$s_{ij} \leftarrow \frac{m_{ik}}{m_{jk}}$\;
					$j \leftarrow j+1$\;						
				}
				$i \leftarrow i+1$\;			
			}
			}%%end						
		
\end{algorithm*}}

%\begin{figure}[t!]
%	\myAllNIAGARA
%	\caption{Главный алгоритм NIAGARA-2}\label{alg:NIAGARA-main}
%\end{figure}
%
%
\myPWMwithoutConc



Пример. Пусть признак \emph{b} имеет значения \{65, 95, 105, 170\}. Видно, что
между соседними величинами разное относительное расстояние. В таком
случае создается МПС, представленная результатом преобразования~\eqref{eq-untrans1}.

\begin{equation}\label{eq-untrans1}
%\begin{matrix}
	\begin{pmatrix}
		1 & \frac{65}{95} & \frac{65}{105} & \frac{65}{170} \\
		0 & 1 & \frac{95}{105} & \frac{95}{170} \\
		0 & 0 & 1 & \frac{105}{170} \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix} \rightarrow \begin{pmatrix}
		1 & 0,68 & 0,62 & 0,38 \\
		0 & 1 & 0,9 & 0,56 \\
		0 & 0 & 1 & 0,62 \\
		0 & 0 & 0 & 1 
	\end{pmatrix}
%\end{matrix}
\end{equation}

Если же попробовать посчитать МПС по первому алгоритму, то в
транзитивности между элементами 65 и 170 возникнет ошибка, приведем расчет на примере~\eqref{eq-untrans0}.

\begin{equation}\label{eq-untrans0}
%\begin{matrix}
	\begin{pmatrix}
		1 & \frac{65}{95} & - & - \\
		0 & 1 & \frac{95}{105} & - \\
		0 & 0 & 1 & \frac{105}{170} \\
		0 & 0 & 0 & 1 \\
	\end{pmatrix} \rightarrow \begin{pmatrix}
		1 & 0,68 & 0,62 & 0,35 \\
		0 & 1 & 0,9 & 0,56 \\
		0 & 0 & 1 & 0,62 \\
		0 & 0 & 0 & 1 
	\end{pmatrix}
%\end{matrix}
\end{equation}

Между \eqref{eq-untrans0} и \eqref{eq-untrans1} видно несоответствие между числами 0,38 и 0,35.

В силу этих причин авторы статьи рекомендуют импортировать таблицы после
предварительной проверки сверхтранзитивности, вводить данные в систему
вручную (с учетом верификации противоречий системой) или комбинировать
оба алгоритма, например, чтобы исследовать противоречия в рассуждениях.
В следующем разделе приведено проектирование классов приложения.

\section{ПРОЕКТИРОВАНИЕ КЛАССОВ СИСТЕМЫ ПОДДЕРЖКИ ПРИНЯТИЯ РЕШЕНИЙ}
%
%
%
%
Программа состоит из трех основных классов: Application, csvReader и ranker.
%
%\begin{itemize}
%	\item 
%	application;
%	\item
%	csvReader;
%	\item
%	ranker.
%\end{itemize}

Класс Application запускает основной цикл и предоставляет возможность
ввода для выбора действия. Пользователь может выбрать импорт таблицы,
настройки и выход.

Настройки позволяют выбрать основание предпочтения (таблица~\ref{table-scales-KP}),
отображение дополнительной информации (МПС), и способ расчета оценки.

При выборе импорта таблицы пользователь вводит путь к файлу, после чего
CSVReader читает файл и возвращает двумерный массив класса Object.
Данный массив разделяется на массив признаков и двумерный массив
альтернатив со значениями по каждому признаку. Эти данные передаются в
класс Ranker.

Ranker проводит опрос пользователя по важности признаков и их
направлении оптимизации.

Предполагается работа с тремя векторами: head, optimization,
attributeAnswers, и одна матрица: data, которые переходят в методы
SimpleRankObjects или CoggerYuRankObjects. Выбор метода зависит от
выбранной настройки (по умолчанию задан CoggerYuRankObjects).

Открытая реализация программы приведена по ссылке~\cite{ParkhLaz2024}. Далее
перейдем к краткому описанию функционального тестирования программы.

\section{МОДУЛЬНОЕ ТЕСТИРОВАНИЕ ПРОГРАММЫ}


Для того, чтобы проверить корректность работы приложения были
сформированы тестовые сценарии. Для реализации тестовых сценариев
выбраны модульные тесты.

Проверяются следующие модули системы:

\begin{itemize}
	\item
	произведение делящей матрицы на матрицу парных сравнений;
	\item
	нахождение вектора сумм;
	\item
	нахождение весов объектов (признаков или альтернатив);
	\item
	нормализация весов.
\end{itemize}

В тестах проверяется сходство полученных значений с ожидаемыми в
окрестности \(\varepsilon = 0,001\) (погрешность расчета). В таблице~\ref{table-testing-1}%--\ref{table-testing-4}
представлены входные данные и ожидаемые значения.



\begin{table}[H]
	\centering
	\caption{
		Описание контрольных примеров}
	\label{table-testing-1}
	\small
	%	        \begin{tabular}{llllllllll}
		\begin{tabular}{|c|c|c|}
			%	        \begin{tabular}{|p{5cm}|c|}
				\hline
				\centering
			Тестируемый метод	&Входные данные & Ожидаемый результат \\ 		            \hline
			Произведение \(D^{- 1}S\)
			 & \(\begin{pmatrix}
				1 & 4 & 3 & 7 \\
				0 & 1 & \frac{1}{3} & 3 \\
				0 & 0 & 1 & 5 \\
				0 & 0 & 0 & 1 \\
			\end{pmatrix}\) \cite{Krivulin2024} & 
			\(\begin{pmatrix}
				\frac{1}{4} & 1 & \frac{3}{4} & \frac{7}{4} \\
				0 & \frac{1}{3} & \frac{1}{9} & 1 \\
				0 & 0 & \frac{1}{2} & \frac{5}{2} \\
				0 & 0 & 0 & 1 \\
			\end{pmatrix}\) \\ 
				\hline
			Расчет вектора сумм & \(\begin{pmatrix}
				\frac{1}{4} & 1 & \frac{3}{4} & \frac{7}{4} \\
				0 & \frac{1}{3} & \frac{1}{9} & 1 \\
				0 & 0 & \frac{1}{2} & \frac{5}{2} \\
				0 & 0 & 0 & 1 \\
			\end{pmatrix}\) & \(\begin{pmatrix}
				\frac{15}{4} \\
				\frac{13}{9} \\
				3 \\
				1 \\
			\end{pmatrix}\) \\ 
			\hline
			Расчет весов & 	\(\begin{pmatrix}
				\frac{1}{4} & 1 & \frac{3}{4} & \frac{7}{4} \\
				0 & \frac{1}{3} & \frac{1}{9} & 1 \\
				0 & 0 & \frac{1}{2} & \frac{5}{2} \\
				0 & 0 & 0 & 1 \\
			\end{pmatrix}\), \(\begin{pmatrix}
				\frac{15}{4} \\
				\frac{13}{9} \\
				3 \\
				1 \\
			\end{pmatrix}\) & \(\begin{pmatrix}
				6,3819 \\
				1,8148 \\
				4 \\
				1 \\
			\end{pmatrix}\) \\ 
			\hline
			Расчет $\omega$ & \(\begin{pmatrix}
				6,3819 \\
				1,8148 \\
				4 \\
				1 \\
			\end{pmatrix}\) & \(\begin{pmatrix}
				0,4835 \\
				0,1375 \\
				0,3031 \\
				0,0757 \\
			\end{pmatrix}\)\\
			\hline
			\end{tabular}
		\end{table}



%\begin{table}[H]
%	\centering
%	\caption{
%		Входные и ожидаемые данные тестирования нахождения вектора сумм}
%	\label{table-testing-2}
%	\small
%	%	        \begin{tabular}{llllllllll}
%		\begin{tabular}{|c|c|}
%			%	        \begin{tabular}{|p{5cm}|c|}
%				\hline
%				\centering
%				Входные данные & Ожидаемый результат \\ 		            \hline
%				$\(\begin{pmatrix}
%					\frac{1}{4} & 1 & \frac{3}{4} & \frac{7}{4} \\
%					0 & \frac{1}{3} & \frac{1}{9} & 1 \\
%					0 & 0 & \frac{1}{2} & \frac{5}{2} \\
%					0 & 0 & 0 & 1 \\
%				\end{pmatrix}\) & \(\begin{pmatrix}
%					\frac{15}{4} \\
%					\frac{13}{9} \\
%					3 \\
%					1 \\
%				\end{pmatrix}\)$ \\ 
%				\hline
%			\end{tabular}
%		\end{table}



%\begin{table}[H]
%	\centering
%	\caption{
%		Входные и ожидаемые данные тестирования нахождения весов}
%	\label{table-testing-3}
%	\small
%	%	        \begin{tabular}{llllllllll}
%		\begin{tabular}{|c|c|}
%			%	        \begin{tabular}{|p{5cm}|c|}
%				\hline
%				\centering
%				Входные данные & Ожидаемый результат \\ 		            \hline
%				$\(\begin{pmatrix}
%					\frac{1}{4} & 1 & \frac{3}{4} & \frac{7}{4} \\
%					0 & \frac{1}{3} & \frac{1}{9} & 1 \\
%					0 & 0 & \frac{1}{2} & \frac{5}{2} \\
%					0 & 0 & 0 & 1 \\
%				\end{pmatrix}\), \(\begin{pmatrix}
%					\frac{15}{4} \\
%					\frac{13}{9} \\
%					3 \\
%					1 \\
%				\end{pmatrix}\) & \(\begin{pmatrix}
%					6,3819 \\
%					1,8148 \\
%					4 \\
%					1 \\
%				\end{pmatrix}\)$ \\ 
%				\hline
%			\end{tabular}
%		\end{table}

%
%Таблица 6.4
%
%Входные и ожидаемые данные тестирования нормализации весов
%
%\begin{longtable}[]{@{}
%		>{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
%		>{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
%	\toprule()
%	\begin{minipage}[b]{\linewidth}\raggedright
%		Входные данные
%	\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
%		Ожидаемый выход
%	\end{minipage} \\
%	\midrule()
%	\endhead
%	\(\begin{pmatrix}
%		6,3819 \\
%		1,8148 \\
%		4 \\
%		1 \\
%	\end{pmatrix}\) & \(\begin{pmatrix}
%		0,4835 \\
%		0,1375 \\
%		0,3031 \\
%		0,0757 \\
%	\end{pmatrix}\) \\
%	\bottomrule()
%\end{longtable}

Для тестирования используется фреймворк JUnit. Он позволяет
разработчикам писать и запускать тесты для проверки правильности работы
отдельных модулей (классов, методов) в их коде. JUnit предоставляет
аннотации, такие как @Test, @Before, @After и другие, которые упрощают
процесс написания тестов и организацию тестового кода.

Разработанные модульные тесты показывают, что результат расчета системы
совпадает с ожидаемым выходом, следовательно есть доля уверенности, что
расчеты в приложении производятся верно. Однако, перед коммерческим
использованием, авторы рекомендуют дополнительно использовать другие
техники тестирования, такие как фаззинг, промышленные статические
анализаторы и др. Тесты помещены в том же открытом репозитории, что и
реализованное приложение~\cite{ParkhLaz2024}.

Далее перейдем к описанию ручного тестирования программы.


\section{РУЧНОЕ ТЕСТИРОВАНИЕ ПРОГРАММЫ}


Для начала работы с приложением необходимо скачать~\cite{ParkhLaz2024} и
разархивировать приложение. Самым простым способом является
использование среды разработки IntelliJ IDEA. Проект запускается из
класса MCD.Main.java.

Альтернативным способом сборки является установка Maven в проект. В
таком случае необходимо будет вручную составить pom.xml. То же самое
можно сделать с помощью Gradle. Для этого необходимо удалить
CoggerYu.iml, после чего инициализировать build.gradle.

Для работы необходимо импортировать таблицу вида (таблица~\ref{table-import-data}).



\begin{table}[H]
	\centering
	\caption{Вид импортируемых данных}
	\label{table-import-data}
	\small
	%	        \begin{tabular}{llllllllll}
			\begin{tabular}{|c|c|c|c|}
					%	        \begin{tabular}{|p{5cm}|c|}
							\hline
							\centering
							Признак 1& Признак 2 &\ldots & Признак N \\ 		            \hline
								Значение\_11 & Значение\_12 & \ldots{} & Значение\_1N \\
								\ldots{} & \ldots{} & \ldots{} & \ldots{} \\
								Значение\_M1 & Значение\_M2 & \ldots{} & Значение\_MN \\
							\hline
						\end{tabular}
				\end{table}


%
%%\begin{longtable}[]{@{}
%%		>{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2499}}
%%		>{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2499}}
%%		>{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2501}}
%%		>{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2501}}@{}}
%%	\toprule()
%%	\begin{minipage}[b]{\linewidth}\raggedright
%%		Признак\_1
%%	\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
%%		Признак\_2
%%	\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
%%		\ldots{}
%%	\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
%%		Признак\_N
%%	\end{minipage} \\
%%	\midrule()
%%	\endhead
%%	Значение\_11 & Значение\_12 & \ldots{} & Значение\_1N \\
%%	\ldots{} & \ldots{} & \ldots{} & \ldots{} \\
%%	Значение\_M1 & Значение\_M2 & \ldots{} & Значение\_MN \\
%%	\bottomrule()
%%\end{longtable}
%
Важно, чтобы в названии признаков не было пробелов, также важно, чтобы
все значения признаков были численными.

Для общения с диалоговой системой пользователь вводит числа, почти
пе-ред каждым вопросом пользователю показывается меню, чтобы можно было
понять, какой список действий доступен.

Для начала вычислений пользователю необходимо импортировать файл
расширения csv или txt, в которых присутствует заглавная строка, в
качестве разделителей используется «,», а сами значения являются
числовыми.

После импорта таблицы пользователь отвечает на вопросы о том, какие
признаки для него наиболее важны и какие наименее важны. Также у
пользователя спрашивают направление оптимизации для каждого признака.
После происходит расчет всех значений, и пользователь получает оценку
для каждой альтернативы. На рисунке~\ref{fig:Cogger-system-console} представлен пример работы с
системой.

    \begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth,keepaspectratio]{vertopal_e4e57282f7da49f4b12d2e1664ac28e6/media/image2.png}\caption{Пример работы с диалоговой системой}\label{fig:Cogger-system-console}
\end{figure}

Далее перейдем к решению прикладных задач методом Коггера и Ю и
сравнению результатов с другими методами парных сравнений.



\section{СРАВНЕНИЕ РЕЗУЛЬТАТОВ МЕТОДА КОГГЕРА И Ю С РЕШЕНИЕМ МАИ, СРЕДНЕГО ГЕОМЕТРИЧЕСКОГО И МИНМАКС ЛОГ-ЧЕБЫШЕВСКОГО МЕТОДА АППРОКСИМАЦИИ}



Рассмотрим пример из статьи~\cite{Krivulin2024}. В ней исследуется задача выбора
руководителя проекта в области программирования. Кандидаты попарно
оцениваются по \(K = 4\) признакам: 1) персональные качества, 2)
академические достижения, 3) опыт работы в команде, 4) уровень
программирования. Матрица парных сравнений для метода Коггера и Ю имеет
вид:
\begin{equation*}\label{}
C = \begin{pmatrix}
	1 & 4 & 3 & 7 \\
	0 & 1 & \frac{1}{3} & 3 \\
	0 & 0 & 1 & 5 \\
	0 & 0 & 0 & 1
\end{pmatrix}.\end{equation*}

\(N = 4\), т.е. рассмотрены кандидаты \(A_{1}\), \(A_{2}\), \(A_{3}\),
\(A_{4}\), результаты оценки которых по каждому признаку отражают
следующие матрицы парных сравнений:

\begin{align*}\label{}
A_{1} = \begin{pmatrix}
	1 & 2 & 3 & 4 \\
	0 & 1 & 3 & 2 \\
	0 & 0 & 1 & \frac{1}{3} \\
	0 & 0 & 0 & 1 \\
\end{pmatrix},
A_{2} = \begin{pmatrix}
	1 & 2 & 3 & 4 \\
	0 & 1 & 2 & 3 \\
	0 & 0 & 1 & 2 \\
	0 & 0 & 0 & 1 \\
\end{pmatrix},
%\end{align*}
%\begin{align*}\label{}
A_{3} = \begin{pmatrix}
	1 & 2 & 2 & 3 \\
	0 & 1 & 2 & 3 \\
	0 & 0 & 1 & 2 \\
	0 & 0 & 0 & 1 \\
\end{pmatrix},
 A_{4} = \begin{pmatrix}
	1 & 3 & 2 & 3 \\
	0 & 1 & 2 & 4 \\
	0 & 0 & 1 & 1 \\
	0 & 0 & 0 & 1 \\
\end{pmatrix}.
\end{align*}

Необходимо рассчитать веса признаков \emph{w} матрицы C, а также веса
альтернатив по признакам \(\omega_{i}\) по матрицам \(A_{1}\),
\(A_{2}\), \(A_{3}\), \(A_{4}\). Строится делящая матрица \(D^{- 1}\):

\begin{equation*}\label{}
D^{- 1} = \begin{pmatrix}
	\frac{1}{4} & 0 & 0 & 0 \\
	0 & \frac{1}{3} & 0 & 0 \\
	0 & 0 & \frac{1}{2} & 0 \\
	0 & 0 & 0 & 1 
\end{pmatrix}.\end{equation*}

Она будет идентичной для всех МПС в данной задаче, так как все они имеют
одинаковый размер. После для каждого объекта (признаков или альтернатив
по признаку) происходит умножение делящей матрицы \(D^{- 1}\) на МПС
объекта:

\begin{align*}\label{}
&D^{- 1}C = \begin{pmatrix}
	\frac{1}{4} & 1 & \frac{3}{4} & \frac{7}{4} \\
	0 & \frac{1}{3} & \frac{1}{9} & 1 \\
	0 & 0 & \frac{1}{2} & \frac{5}{2} \\
	0 & 0 & 0 & 1 
\end{pmatrix},
%\end{align*}
%\begin{equation}\label{}
{D^{- 1}A}_{1} = \begin{pmatrix}
	\frac{1}{4} & \frac{1}{2} & \frac{3}{4} & 1 \\
	0 & \frac{1}{3} & 1 & \frac{2}{3} \\
	0 & 0 & \frac{1}{2} & \frac{1}{6} \\
	0 & 0 & 0 & 1 \\
\end{pmatrix},
 {D^{- 1}A}_{2} = \begin{pmatrix}
	\frac{1}{4} & \frac{1}{2} & \frac{3}{4} & 1 \\
	0 & \frac{1}{3} & \frac{2}{3} & 1 \\
	0 & 0 & \frac{1}{2} & 1 \\
	0 & 0 & 0 & 1 \\
\end{pmatrix}, \\
%\end{equation}
%\begin{equation}\label{}
& D^{- 1}A_{3} = \begin{pmatrix}
	\frac{1}{4} & \frac{1}{2} & \frac{1}{2} & \frac{3}{2} \\
	0 & \frac{1}{3} & \frac{2}{3} & 1 \\
	0 & 0 & \frac{1}{2} & 1 \\
	0 & 0 & 0 & 1 \\
\end{pmatrix},\ 
{D^{- 1}A}_{4} = \begin{pmatrix}
	\frac{1}{4} & \frac{3}{4} & \frac{1}{2} & \frac{3}{4} \\
	0 & \frac{1}{3} & \frac{2}{3} & \frac{4}{3} \\
	0 & 0 & \frac{1}{2} & \frac{1}{2} \\
	0 & 0 & 0 & 1 \\
\end{pmatrix}.
\end{align*}

Далее для каждой матрицы создается вектор \emph{a}, элементами которого
являются суммы каждой строки полученного произведения:

\begin{align*}\label{}
a_{C} = \begin{pmatrix}
	\frac{15}{4} \\
	\frac{13}{9} \\
	3 \\
	1 \\
\end{pmatrix},
%\end{equation}
%\begin{equation}\label{}
a_{A_{1}} = \begin{pmatrix}
	\frac{10}{4} \\
	2 \\
	\frac{4}{6} \\
	1 \\
\end{pmatrix},
 a_{A_{2}} = \begin{pmatrix}
	\frac{10}{4} \\
	2 \\
	\frac{3}{2} \\
	1 \\
\end{pmatrix},
%\end{equation}
%\begin{equation}\label{}
a_{A_{3}} = \begin{pmatrix}
	\frac{11}{4} \\
	2 \\
	\frac{3}{2} \\
	1 \\
\end{pmatrix},
\ a_{A_{4}} = \begin{pmatrix}
	\frac{11}{4} \\
	\frac{7}{3} \\
	1 \\
	1 \\
\end{pmatrix}.
\end{align*}

Затем необходимо умножить произведения \(D^{- 1}M\) на вектор \emph{a}
для получения весов:

\begin{align*}\label{}
& D^{- 1}Ca_{C} = w = \begin{pmatrix}
	6,3819 \\
	1,8148 \\
	4 \\
	1 \\
\end{pmatrix},
%\end{equation}
%\begin{equation}\label{}
D^{- 1}A_{1}a_{A_{1}} = \omega_{1} = \begin{pmatrix}
	3,125 \\
	2 \\
	0,5 \\
	1 \\
\end{pmatrix},\
 D^{- 1}A_{2}a_{A_{2}} = \omega_{2} = \begin{pmatrix}
	3,75 \\
	2,666 \\
	1,75 \\
	1 \\
\end{pmatrix},\\
%\end{equation}
%\begin{align*}\label{}
& D^{- 1}A_{3}a_{A_{3}} = \omega_{3} = \begin{pmatrix}
	3,125 \\
	2 \\
	0,5 \\
	1 \\
\end{pmatrix},
\ D^{- 1}A_{4}a_{A_{4}} = \omega_{4} = \begin{pmatrix}
	3,75 \\
	2,666 \\
	1,75 \\
	1 \\
\end{pmatrix}.\end{align*}

После этого все веса нормализуются по формуле~\eqref{eq:omega-1} для выполнения условия
\(\sum_{i = 1}^{n}{w_{i} = 1}\). Далее рассчитываются оценки по формуле~\eqref{eq:alternatives-scalar-evaluation}:

\begin{equation*}\label{}
\omega w = \begin{pmatrix}
	0,4247 \\
	0,3072 \\
	0,1348 \\
	0,1330 \\
\end{pmatrix}.\end{equation*}

В статье [5] провели расчет несколькими способами. С помощью метода
Саати получаются оценки \((\omega w)^{T} =\) 
$\begin{pmatrix}
	0,4535; & 0,2767; & 0,1304; & 0,1394 \\
\end{pmatrix}^{T}$.

 С помощью метода взвешенных геометрических средних
получаются оценки \((\omega w)^{T} =\) 
$\begin{pmatrix}
	2,1037; & 1,3139; & 0,5761; & 0,6280 \\
\end{pmatrix}^{T}$.

 Метод log-Чебышевской аппроксимации [5,24-26]
дал результат 
$\min = ($1;\  0,4262;\  0,1991;\  0,3568$)^{T}$ и $\max = \begin{pmatrix}
	1; & 0,8371; & 0,2336; & 0,4185 \\
\end{pmatrix}^{T}$.

Видно, что оценки приоритета 3 и 4 альтернатив по методу Коггера и Ю
почти одинаковые и можно говорить об эквивалентности данных альтернатив
по предпочтению, так как различие приоритетов альтернатив измеряется
одной тысячной. Схожий результат получается МАИ, однако их ранги
меняются местами. В двух оставшихся методах ранжирование альтернатив
аналогично МАИ, однако различимость по значениям приоритетов больше. Это
может быть полезным, если каждому объекту нужно сопоставить отдельный
ранг.




\section{СРАВНЕНИЕ РЕЗУЛЬТАТОВ МЕТОДА КОГГЕРА И Ю С РЕШЕНИЕМ МАИ И ТЕОРИИ ВАЖНОСТИ КРИТЕРИЕВ}


Рассмотрим статью~\cite{Podinovskiy2007}, где доказана некорректность метода
аналитической иерархии Саати. Берется задача с двумя равноважными
признаками, для них строится матрица парных сравнений:
\begin{equation*}\label{}
A = \begin{pmatrix}
	1 & 1 \\
	0 & 1 \\
\end{pmatrix}.\end{equation*}

Матрицы парных сравнений, где на диагонали и выше нее единицы, а ниже
нули, в методе Коггера и Ю при любых размерах МПС дадут такой вектор
весов, в котором все элементы равны. Для данной МПС
\(w = \begin{pmatrix}
	0,5 \\
	0,5 \\
\end{pmatrix}\).

Далее задаются две параметризованные матрицы парных сравнений
альтернатив по каждому признаку:
\begin{equation*}\label{}
F_{1} = \begin{pmatrix}
	1 & ab & a & 1 \\
	0 & 1 & \frac{1}{b} & \frac{1}{ab} \\
	0 & 0 & 1 & \frac{1}{a} \\
	0 & 0 & 0 & 1 \\
\end{pmatrix},\ F_{2} = \begin{pmatrix}
	1 & \frac{1}{a} & 1 & b \\
	0 & 1 & a & ab \\
	0 & 0 & 1 & b \\
	0 & 0 & 0 & 1 \\
\end{pmatrix}.\end{equation*}

При параметрах \(a = 3\), \(b = 3\) получаются следующие веса:

\begin{equation*}\label{}
\omega_{1} = \begin{pmatrix}
	0,6045 \\
	0,0606 \\
	0,1116 \\
	0,2232 \\
\end{pmatrix},\ \omega_{2} = \begin{pmatrix}
	0,1635 \\
	0,5420 \\
	0,2102 \\
	0,0841 \\
\end{pmatrix},\end{equation*}

после чего рассчитаем методом Коггера и Ю итоговые оценки (таблица~\ref{table-Podinovsky-Kogger}).

\begin{table}[H]
	\centering
	\caption{Итоговая оценка при различных параметрах \emph{a} и \emph{b} по методу
		Коггера и Ю}
	\label{table-Podinovsky-Kogger}
	\small
	%	        \begin{tabular}{llllllllll}
		\begin{tabular}{|c|c|c|c|}
			%	        \begin{tabular}{|p{5cm}|c|}
				\hline
				\centering
				$a$ &  3 & 3 & 4 \\ 		            \hline
				$b$ &  3 & 2 & 2 \\ 		            \hline
				\(x_{1}\) & 0,3840 & 0,3564 & 0,3768 \\
				\(x_{2}\) & 0,3013 & 0,3051 & 0,3329 \\
				\(x_{3}\) & 0,1609 & 0,1602 & 0,1327 \\
				\(x_{4}\) & 0,1536 & 0,1781 & 0,1574 \\
				\hline
			\end{tabular}
		\end{table}



Основная претензия к методу Саати~\cite{Saaty1977} в том, при всех параметрах из
таблицы~\ref{table-Podinovsky-Kogger} получается ранжировка
\(x_{2} \succ x_{1} \succ x_{4} \succ x_{3}\), хотя при расчете по
теории важности критериев альтернатива \(x_{1}\) должна быть лучше, чем
\(x_{2}\) (рисунок~\ref{fig:Podinovsky}).

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.33\textwidth,keepaspectratio]{vertopal_e4e57282f7da49f4b12d2e1664ac28e6/media/image3.png}\caption{Частичная упорядоченность вариантов по двум равноважным признакам~\cite{Podinovskiy2007}}\label{fig:Podinovsky}
\end{figure}


Исходя из таблицы~\ref{table-Podinovsky-Kogger} методом Коггера и Ю получена ранжировка
\(x_{1} \succ x_{2} \succ x_{3} \succ x_{4}\). Варианты \(x_{3}\) и
\(x_{4}\) сменяют друг друга в полученной ранжировке в зависимости от
параметров, но если считать объекты эквивалентными с погрешностью
\(\varepsilon = 0,02\), то данная ранжировка более соответствует результатам,
полученным с помощью теории важности критериев~\cite{Podinovskiy2007}, хотя $x_{2}$ и $x_{4}$ здесь по-прежнему не равноважны, а \(x_{3}\) и
\(x_{4}\) являются сравнимыми и равноважными.

Далее перейдем к описанию задачи принятия решений, составленной
авторами.


\section{РЕШЕНИЕ ЗАДАЧИ РАНЖИРОВАНИЯ АЛГОРИТМОВ ГЕНЕРАЦИИ УРОВНЕЙ ДЛЯ КОМПЬЮТЕРНЫХ ИГР В ДВУХМЕРНОМ ПРОСТРАНСТВЕ}


Решение задачи ранжирования алгоритмов генерации уровней для
компьютерных игр проведено с целью выбора алгоритмов-кандидатов для
дальнейших улучшений данных алгоритмов.

Составим таблицу~\ref{table-game-levels} с оценкой альтернатив по критериям, а также укажем
в ней направление оптимизации. Признаки: 1) повторяемость (количество
паттернов в уровне), 2) управляемость (количество параметров, которые
могут управлять алгоритмом), 3) удобство использования (как много усилий
должен приложить пользователь, чтобы получить желаемую карту),
порядковая шкала, 4) сложность реализации (количество используемых
библиотек, концептуальная сложность алгоритмов), порядковая шкала.
Значения альтернатив представлены в таблице~\ref{table-game-levels}, где \(g_{1}\) --
IORand~\cite{Moreno2022}, \(g_{2}\) --GB WFC ~\cite{Kim2020}, \(g_{3}\) --PBDG~\cite{Bagus2022},
\(g_{4}\) -- WASPAS~\cite{Petrovas2022}, \(g_{5}\) -- PCGQD~\cite{Gravina2019}, \(g_{6}\) --
RBCAA~\cite{Gellel2020}, \(g_{7}\) --PSOCG~\cite{Pontes2022}. Стрелки $\uparrow$ и $\downarrow$ означают соответственно максимизируется или минимизируется признак. В зависимости от этого будет производиться нормализация в соответствие с формулами~\ref{eq:omega-1} или~\ref{eq:omega-2}.


\begin{table}[H]
	\centering
	\caption{Оценка алгоритмов процедурной генерации игровых уровней}
	\label{table-game-levels}
	\small
	%	        \begin{tabular}{llllllllll}
		\begin{tabular}{|c|c|c|c|c|}
			%	        \begin{tabular}{|p{5cm}|c|}
				\hline
				\centering
				 \makecell[t]{N} &  \makecell[t]{Повторяемость $\downarrow$} &  \makecell[t]{Управляемость $\uparrow$}   &  \makecell[t]{Удобство использования  $\uparrow$} & \makecell[t]{Сложность \\ реализации $\downarrow$}  \\ 		            \hline
\(g_{1}\) & 35 & 4 & 3 & 3 \\
\(g_{2}\) & 20 & 4 & 3 & 2 \\
\(g_{3}\) & 72 & 3 & 1 & 1 \\
\(g_{4}\) & 24 & 3 & 2 & 1 \\
\(g_{5}\) & 33 & 2 & 2 & 2 \\
\(g_{6}\) & 40 & 1 & 3 & 1 \\
\(g_{7}\) & 55 & 1 & 2 & 3 \\
				\hline
			\end{tabular}
		\end{table}


Важность признаков задается экспертом: (10, 8, 6, 5). Все матрицы парных сравнений строятся по алгоритму создания МПС при отсутствии транзитивности:

\begin{equation*}\label{}
S = \begin{pmatrix}
	1 & \frac{10}{8} & \frac{10}{6} & \frac{1}{2} \\
	0 & 1 & \frac{8}{6} & \frac{8}{5} \\
	0 & 0 & 1 & \frac{6}{5} \\
	0 & 0 & 0 & 1 \\
\end{pmatrix}, 
S_{1} = \begin{pmatrix}
	1 & \frac{35}{20} & \frac{35}{72} & \frac{35}{24} & \frac{35}{33} & \frac{35}{40} & \frac{35}{55} \\
	0 & 1 & \frac{20}{72} & \frac{20}{24} & \frac{20}{33} & \frac{1}{2} & \frac{20}{55} \\
	0 & 0 & 1 & 3 & \frac{72}{33} & \frac{72}{40} & \frac{72}{55} \\
	0 & 0 & 0 & 1 & \frac{24}{33} & \frac{24}{40} & \frac{24}{55} \\
	0 & 0 & 0 & 0 & 1 & \frac{33}{40} & \frac{33}{55} \\
	0 & 0 & 0 & 0 & 0 & 1 & \frac{40}{55} \\
	0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{pmatrix},\end{equation*}

\begin{equation*}\label{}
S_{2} = \begin{pmatrix}
	1 & 1 & \frac{4}{3} & \frac{4}{3} & 2 & 4 & 4 \\
	0 & 1 & \frac{4}{3} & \frac{4}{3} & 2 & 4 & 4 \\
	0 & 0 & 1 & 1 & \frac{3}{2} & 3 & 3 \\
	0 & 0 & 0 & 1 & \frac{3}{2} & 3 & 3 \\
	0 & 0 & 0 & 0 & 1 & 2 & 2 \\
	0 & 0 & 0 & 0 & 0 & 1 & 1 \\
	0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{pmatrix},
S_{3} = \begin{pmatrix}
	1 & 1 & 3 & \frac{3}{2} & \frac{3}{2} & 1 & \frac{3}{2} \\
	0 & 1 & 3 & \frac{3}{2} & \frac{3}{2} & 1 & \frac{3}{2} \\
	0 & 0 & 1 & \frac{1}{2} & \frac{1}{2} & \frac{1}{3} & \frac{1}{2} \\
	0 & 0 & 0 & 1 & 1 & \frac{2}{3} & 1 \\
	0 & 0 & 0 & 0 & 1 & \frac{2}{3} & 1 \\
	0 & 0 & 0 & 0 & 0 & 1 & \frac{3}{2} \\
	0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}, 
S_{4} = \begin{pmatrix}
	1 & \frac{3}{2} & 3 & 3 & \frac{3}{2} & 3 & 1 \\
	0 & 1 & 2 & 2 & 1 & 2 & \frac{2}{3} \\
	0 & 0 & 1 & 1 & \frac{1}{2} & 1 & \frac{1}{3} \\
	0 & 0 & 0 & 1 & \frac{1}{2} & 1 & \frac{1}{3} \\
	0 & 0 & 0 & 0 & 1 & 2 & \frac{2}{3} \\
	0 & 0 & 0 & 0 & 0 & 1 & \frac{1}{3} \\
	0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}.\end{equation*}

Для упрощения расчетов можно не создавать делящую матрицу \(D^{- 1}\), а
поделить строки матриц согласно алгоритму произведения делящей матрицы на матрицу парных сравнений. Из произведения делящей матрицы на МПС получаются векторы сумм:

\begin{equation*}\label{}
a = \begin{pmatrix}
	1,4791 \\
	1,3111 \\
	1,1 \\
	1 \\
\end{pmatrix},
a_{1} = \begin{pmatrix}
	1,038 \\
	0,5968 \\
	1,8581 \\
	0,6909 \\
	0,8083 \\
	0,8636 \\
	1 \\
\end{pmatrix},\ a_{2} = \begin{pmatrix}
	2,0952 \\
	2,2777 \\
	1,9 \\
	2,125 \\
	1,6666 \\
	1 \\
	1 \\
\end{pmatrix},
a_{3} = \begin{pmatrix}
	1,5 \\
	1,5833 \\
	0,5666 \\
	0,9166 \\
	0,8888 \\
	1,25 \\
	1 \\
\end{pmatrix},\ a_{4} = \begin{pmatrix}
	2 \\
	1,4444 \\
	0,7666 \\
	0,7083 \\
	1,2222 \\
	0,6666 \\
	1 \\
\end{pmatrix}.\end{equation*}

С помощью данных векторов вычисляются соответственные веса, которые
проходят нормализацию (формула~\eqref{eq:alternatives-scalars}, затем~\eqref{eq:omega-1} или~\eqref{eq:omega-2}):

\begin{equation*}\label{}
w = \begin{pmatrix}
	0,3250 \\
	0,2729 \\
	0,2150 \\
	0,1870 \\
\end{pmatrix},
\omega_{1} = \begin{pmatrix}
	0,1409 \\
	0,2052 \\
	0,0078 \\
	0,1950 \\
	0,1709 \\
	0,1565 \\
	0,1233 \\
\end{pmatrix},\ \omega_{2} = \begin{pmatrix}
	0,1977 \\
	0,2077 \\
	0,1645 \\
	0,1744 \\
	0,1240 \\
	0,0656 \\
	0,0656 \\
\end{pmatrix},
\omega_{3} = \begin{pmatrix}
	0,1927 \\
	0,1919 \\
	0,0628 \\
	0,1198 \\
	0,1195 \\
	0,1811 \\
	0,1317 \\
\end{pmatrix},\ \omega_{4} = \begin{pmatrix}
	0,0100 \\
	0,1032 \\
	0,1970 \\
	0,2023 \\
	0,1313 \\
	0,2138 \\
	0,1420 \\
\end{pmatrix}.\end{equation*}

После этого происходит расчет итоговой оценки по формуле~\ref{eq:alternatives-scalar-evaluation}: $\omega w= 	(0,1431;$ $0,1840;$ $0,0978; 0,1746; 0,1397; 0,1477; 0,1129)^T$.

%\begin{equation*}\label{}
%\omega w = \begin{pmatrix}
%	0,1431 \\
%	0,1840 \\
%	0,0978 \\
%	0,1746 \\
%	0,1397 \\
%	0,1477 \\
%	0,1129 \\
%\end{pmatrix}.\end{equation*}

Получена ранжировка
\(g_{2} \succ g_{4} \succ g_{6} \succ g_{1} \succ g_{5} \succ g_{7} \succ g_{3}\).
Данный пример показывает, как с помощью одной таблицы с вариантами и
оценки признаков получить оценку альтернатив. Также данный пример
учитывает разное направление оптимизации признаков.

Для сравнения эту же задачу решим в системе поддержки принятия
решений СВИРЬ~\cite{Svir,Mikoni2001,Mikoni2009} с помощью метода анализа иерархий, получен
вектор приоритетов объектов
\({(0,15; 0,17; 0,13; 0,16; 0,14; 0,14; 0,11)}^{T}\)в результате чего получена
ранжировка
\(g_{2} \succ g_{4} \succ g_{1} \succ g_{5} \succ g_{6} \succ g_{3} \succ g_{7}\).
Видно, что по сравнению с методом Коггера и Ю часть рейтинга, начиная с
третьего места сильно меняется.

Теперь можно воспользоваться системой поддержки принятия решений DASS~\cite{DASS,Podinovskiy2008,Podinovsky2011}, которая использует методы из теории важности критериев. Для
начала необходимо привести шкалы таблицы~\ref{table-game-levels} к единой шкале, а также сделать их сонаправленными. Для признака «повторяемость» берется четыре
интервала: \{[100;75), [75;50), [50;25), [25;0]\}, по которым
признак загрубляется. В признаке «сложность разработки» числа 1 и 3
меняют друг друга местами (таблица~\ref{table-game-levels-updated}).


\begin{table}[H]
	\centering
	\caption{Оценка алгоритмов процедурной генерации игровых уровней в единой шкале}
	\label{table-game-levels-updated}
	\small
	%	        \begin{tabular}{llllllllll}
		\begin{tabular}{|c|c|c|c|c|}
			%	        \begin{tabular}{|p{5cm}|c|}
				\hline
				\centering
				N &Повторяемость & Управляемость & Удобство использования   & Сложность  реализации   \\ 		            \hline
	\(g_{1}\) & 3 & 4 & 3 & 1 \\
\(g_{2}\) & 4 & 4 & 3 & 2 \\
\(g_{3}\) & 2 & 3 & 1 & 3 \\
\(g_{4}\) & 4 & 3 & 2 & 3 \\
\(g_{5}\) & 3 & 2 & 2 & 2 \\
\(g_{6}\) & 3 & 1 & 3 & 3 \\
\(g_{7}\) & 2 & 1 & 2 & 1 \\
				\hline
			\end{tabular}
		\end{table}


Произведем расчет методом Коггера и Ю, а также с помощью DASS и СВИРЬ по
этим данным. В таблице~\ref{table-game-levels-updated-results} приведены значения оценок альтернатив
методом Коггера и Ю, DASS и СВИРЬ.





\begin{table}[H]
	\centering
	\caption{Значения приоритетов сущностей по методу Коггера и Ю, теории важности
		критериев, рассчитанные в СППР DASS~\cite{DASS} и по МАИ в СППР СВИРЬ~\cite{Svir}}
	\label{table-game-levels-updated-results}
	\small
	%	        \begin{tabular}{llllllllll}
		\begin{tabular}{|c|c|c|c|}
			%	        \begin{tabular}{|p{5cm}|c|}
				\hline
				\centering
				 \makecell[t]{G} &  \makecell[t]{Расчеты \\по Коггеру и Ю} & \makecell[t]{ Расчеты по теории важности \\ критериев с помощью DASS  }& \makecell[t]{Расчеты по методу анализа\\ иерархий с помощью СВИРЬ}  \\ 		            \hline
	\(g_{1}\) & 0,15 & - & 0,1609 \\
\(g_{2}\) & 0,18 & 0,657 & 0,1888 \\
\(g_{3}\) & 0,12 & - & 0,1262 \\
\(g_{4}\) & 0,17 & 0,248 & 0,1720 \\
\(g_{5}\) & 0,13 & - & 0,1288 \\
\(g_{6}\) & 0,15 & 0,094 & 0,1379 \\
\(g_{7}\) & 0,10 & - & 0,0855 \\

			\hline
		\end{tabular}
	\end{table}

Методом Коггера и Ю получена ранжировка
\(g_{2} \succ g_{4} \succ g_{6} \equiv g_{1} \succ g_{5} \succ g_{3} \succ g_{7}\).
Прочерки во второй колонке означают, что альтернативы были отброшены по
Парето. Оставшиеся \(g_{2}\), \(g_{4}\), \(g_{6}\) являются
недоминируемыми. Если уточнять оценку встроенным средством DASS (авторам
статьи не удалось найти математическое описание «уточнения»), то
получается ранжировка \(g_{2} \succ g_{4} \succ g_{6}\), что коррелирует
с результатом, полученным методом Коггера и Ю. Отметим, что расчет по
методу Коггера и Ю в суженном пространстве по Порето может также
привести к большей различимости альтернатив по приоритетам.

Видно, что ранжировки методом Коггера и Ю по исходной таблице и таблице
в единой шкале почти полностью совпадают, что может косвенно означать,
что построенная единая порядковая шкала корректна. Методом анализа
иерархий получена ранжировка
\(g_{2} \succ g_{4} \succ g_{1} \succ g_{6} \succ g_{5} \succ g_{3} \succ g_{7}\).
Результат МАИ немного отклоняется от решений, полученных методом Коггера
и Ю, меняется приоритет первой и шестой альтернатив.

Все три расчета подтверждают перспективность использования алгоритмов GB
WFC~\cite{Kim2020} -- $g_2$ и WASPAS~\cite{Petrovas2022} -- $g_4$ для дальнейшей оптимизации в
рамках генерации игровых уровней.
    \section{ЗАКЛЮЧЕНИЕ}
   
   В ходе исследования подробно проанализирован метод Коггера и Ю.
   Разработана соответствующая СППР с открытым исходным кодом~\cite{ParkhLaz2024},
   которая может быть использовано в рамках принятия решений в
   образовательных и иных целях.
   
   Проведено пошаговое вычисление оценок альтернатив по статьям~\cite{Krivulin2024} и~\cite{Podinovskiy2007}. Выявлено, что ранжировка методом Коггера и Ю может отличаться
   от метода Саати, метода взвешенных геометрических средних и метода
   лог-Чебышевской аппроксимации~\cite{Krivulin2024}. Последние два метода показали
   более сильную различимость оценок приоритетов на рассмотренном примере,
   измеримую десятыми и сотыми долями целого числа, вместо тысячных
   значений у методов Коггера и Ю и Саати. Последнее означает фактическую
   эквивалентность альтернатив по рангам.
   
   Проведены расчёты рангов альтернатив на примере из статьи~\cite{Podinovskiy2007}.
   Выявлено, что метод Коггера и Ю показывает более согласованные результаты с теорией важности критериев, дополнительно сужая множество Парето, но без таких
   противоречий, которые указаны в~\cite{Podinovskiy2007} в рамках критики МАИ. На
   указанном примере это подтверждено с точностью до двух сотых.
   
   В проведенном исследовании сформирована оригинальная задача ранжирования
   альтернатив - алгоритмов генерации уровней для компьютерных игр в
   двухмерном пространстве. Оно проведено с целью выбора
   алгоритмов-кандидатов для дальнейших улучшений данных алгоритмов. В
   результате решения задачи, результаты рейтингов, полученных различными
   методами, показывают «уверенное» первое место у GB WFC~\cite{Kim2020}, а
   второе у\(\ \)-- WASPAS~\cite{Petrovas2022}. Данные алгоритмы выбраны для
   дальнейших улучшений.
   
   В качестве дальнейших шагов авторы планируют проверить появившуюся в рамках данного исследования гипотезу: снижение противоречий в решении методом Коггера и Ю по сравнению с МАИ достигается, прежде всего, тем, что в методе расчета  Коггера и Ю по построению снижается противоречивость в матрице парных сравнений.
   
   
%    Текст заключения с примером ссылки на литературу:~\cite{lib-1,lib-2}

    %Оформляем литературу, 9 означает, что у нас не более 9 пунктов в списке, т.е. все номера состоят из не более, чем одной цифры. Если пунктов много, т.е. номера могут быть двузначными, пишем 99.
    \begin{thebibliography}{99}
    	\bibitem{Krivulin2015}{\it Krivulin, N.} Rating alternatives from pairwise comparisons by solving tropical optimization problems. In 2015 12th International Conference on Fuzzy Systems and Knowledge Discovery (FSKD). IEEE, 2015. P. 162-167. DOI:10.1109/FSKD.2015.7381933. URL:\url{https://ieeexplore.ieee.org/document/7381933}
    	\bibitem{Mikoni2022}{\it Микони, С.В.} Теория принятия управленческих решений: учебное пособие. — СПб.: Издательство «Лань», 2022. — 384 с.
    	\bibitem{Petrovskiy2009}{\it Петровский, А.Б.} Теория принятия решений: учебник для ВУЗов. — М.: Издательский центр «Академия», 2009. — 400 с.
    	\bibitem{Podinovskiy2022}{\it Подиновский, В. В.} Многокритериальные задачи принятия решений: теория и методы анализа: учебник для ВУЗов. — М.: Издательсво Юрайт, 2025. — 486 с.
    	\bibitem{Chern2012}{\it Черноруцкий, И.Г} — Методы принятия решения [Электронный ресурс]: учебное пособие; Санкт-Петербургский государственный политехнический университет.— СПб., 2012.  — Режим доступа:\url{http://elib.spbstu.ru/dl/2358.pdf}.
    	\bibitem{CoggerYu1985} {\it Cogger K. O., Yu P. L.} Eigenweight vectors and least-distance approximation for revealed preference in pairwise weight ratios //Journal of optimization theory and applications. – 1985. – Т. 46. – С. 483-491.
    	\bibitem{Saaty1977}{\it Saaty T. L.} A scaling method for priorities in hierarchical structures //Journal of mathematical psychology. – 1977. – Т. 15. – №. 3. – С. 234-281.    	
    	\bibitem{Superdecisions}  СППР Superdecisions [Электронный ресурс] Режим доступа: \url{https://www.superdecisions.com/}
    	\bibitem{Salimgareev2023} {\it Салимгареев И.А.} AHP [Электронный ресурс] Режим доступа:  URL: \url{https://github.com/DM-app-tools/AHP}
    	\bibitem{ParkhLaz2024} {\it Пархоменко В.А., Лазаренко А.А.} Cистема поддержки ранжирования методом Коггера и Ю [Электронный ресурс] Режим доступа: \url{https://github.com/DM-app-tools/CoggerYuDecisionHelper}
    	\bibitem{Podinovskiy2011} {\it Подиновский, В. В., Подиновская О.В.} О некорректности метода анализа иерархий //Проблемы управления. – 2011. – №. 1. – С. 8-13.
    	\bibitem{Krivulin2024} {\it Кривулин Н.К. и др.} Решение многокритериальных задач оценки альтернатив на основе парных сравнений //Компьютерные инструменты в образовании. – 2024. – №. 2. – С. 5-29.
    	\bibitem{Svir} СППР СВИРЬ [Электронный ресурс] Режим доступа: \url{http://www.mcd-svir.ru/}
		\bibitem{Mikoni2001} {\it Микони С.В.} Система выбора и ранжирования «СВИРЬ» // Труды международного конгресса «Искусственный интеллект в XXI веке». Дивноморское 3–8.09.2001. М.: Физматгиз, 2001. Том 1. С.500-507.
		\bibitem{Mikoni2009} {\it Микони, С. В.  Бураков, Д. П.  Гарина, М. И.} Инструментальная система для выбора задач многокритериального выбора //Программные продукты и системы: научн. и научно-практич. изд. - Тверь, 2009. - № 4 (88). - С. 6-9 .
    	\bibitem{DASS} СППР DASS [Электронный ресурс] Режим доступа: \url{http://mcodm.ru/soft/dass/}
    	\bibitem{Podinovskiy2007} {\it Подиновский В.В., Потапов М.А.} Теоретические основы и системы поддержки принятия многокритериальных решений // Материалы XXXIV Международной конференции “Информационные технологии в науке, образовании, телекоммуникации и бизнесе” (20 - 30 мая 2007 г., Гурзуф, Украина). Приложение к журналу «Открытое образование». 2007. С. 87-89.
    	\bibitem{Podinovskiy2008} {\it Подиновский, В. В.} Анализ задач многокритериального выбора методами теории важности критериев при помощи компьютерных систем поддержки принятия решений / В. В. Подиновский // Известия Российской академии наук. Теория и системы управления. – 2008. – № 2. – С. 64-68. – EDN IJKDPT. 
    	\bibitem{Chern2019} {\it Соколова О. А., Черноруцкий И. Г.} Программная реализация диалоговой системы выбора вариантов на основе метода Коггера и Ю //Неделя науки СПбПУ. – 2019. – С. 64-67.
    	\bibitem{Archimate} Инструмент для формализации Archimate [Электронный ресурс] Режим доступа: \url{https://www.archimatetool.com/}
    	\bibitem{Moreno2022} {\it Moreno-Armendáriz M. A. et al.} IORand: A Procedural Videogame Level Generator Based on a Hybrid PCG Algorithm //Applied Sciences. – 2022. – Т. 12. – №. 8. – С. 3792.
    	\bibitem{Kim2020} {\it Kim H. et al.} Graph based wave function collapse algorithm for procedural content generation in games //IEICE TRANSACTIONS on Information and Sys-tems. – 2020. – Т. 103. – №. 8. – С. 1901-1910.
    	\bibitem{Bagus2022} {\it Bagus Harisa A., Tai W. K.} Pacing-based Procedural Dungeon Level Genera-tion: Alternating Level Creation to Meet Designer’s Expectations //International Journal of Computing and Digital Systems. – 2022. – Т. 12. – №. 1. – С. 401-416.
    	\bibitem{Petrovas2022} {\it Petrovas A., Bausys R.} Procedural video game scene generation by genetic and neutrosophic WASPAS algorithms //Applied Sciences. – 2022. – Т. 12. – №. 2. – С. 772.
    	\bibitem{Gravina2019} {\it Gravina D. et al.} Procedural content generation through quality diversity //2019 IEEE Conference on Games (CoG). – IEEE, 2019. – С. 1-8.
    	\bibitem{Gellel2020} {\it Gellel A., Sweetser P.} A hybrid approach to procedural generation of roguelike video game levels //Proceedings of the 15th International Conference on the Foundations of Digital Games. – 2020. – С. 1-10.
    	\bibitem{Pontes2022} {\it De Pontes R. G., Gomes H. M., Seabra I. S. R.} Particle swarm optimization for procedural content generation in an endless platform game //Entertainment Computing. – 2022. – Т. 43. – С. 100496.
%         \bibitem{lib-1} {\it Madhav S.} Game Programming Algorithms and Techniques: A Platform-Agnostic Approach (Game Design). UK, 2013.
%        \bibitem{lib-2} {\it Ericson C.} Real-Time Collision Detection. USA, 2004.
    \end{thebibliography}

    %дополнительная информация о статье
    \additionalinfo{ГРНТИ 00000}
    \additionalinfo{Поступила в редакцию 2 января 2014, окончательный вариант 24 января 2016 г.}

    %указываем, что теперь начинается английская часть


%\authorI[Пархоменко В.~А.\affil{1}]{Пархоменко Владимир Андреевич}
%\authorIpos{старший преподаватель} % Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого
%\authorIinfo{старший преподаватель Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого}%
%\authorIemailEnvelope{vladimir.parkhomenko@spbstu.ru}
%\authorIorcid{orcid.org/0000-0001-7757-377X}
%
%
%\authorII[Лазаренко А.~А.\affil{1}]{Лазаренко Артем Андреевич}
%\authorIIpos{магистр}% Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого
%\authorIIinfo{магистр Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого}
%\authorIIemail{lazarenko2.aa@edu.spbstu.ru}
%\authorIIorcid{orcid.org/0009-0005-1029-8095}
%
%
%\authorIII[Щукин А.~В.\affil{1}]{Щукин Александр Валентинович}
%\authorIIIpos{к.т.н., доцент}% Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого
%\authorIIIinfo{доцент Высшей школы программной инженерии Института компьютерных технологий и кибербезопасности, Санкт-Петербургский политехнический университет Петра Великого}
%\authorIIIemail{alexander.schukin@spbstu.ru}
%\authorIIIorcid{orcid.org/0000-0002-9534-824X}
%






    \begin{translatedpart}
        %указываем название и авторов на английском
        \title{Cogger and Yu method: an open computer implementation and solution of ranking problems}
        \authorI[Parkhomenko V.~A.\affil{1}]{Parkhomenko Vladimir Andreevich}
        \authorIpos{senior lecturer}
        \authorIinfo{senior lecturer of Higher School of Software Engineering, Institute of Computer Science and Cybersecurity, Peter the Great St.\,Petersburg Polytechnic University}

         \authorII[Lazarenko A.~A.\affil{1}]{Lazarenko Artem Andreevich}
 \authorIIpos{magister}
 \authorIIinfo{magister student of Higher School of Software Engineering, Institute of Computer Science and Cybersecurity, Peter the Great St.\,Petersburg Polytechnic University}
 
         \authorIII[Schukin A.~V.\affil{1}]{Schukin Alexander Valentinovich}
 \authorIIIpos{сand. of Comp.Sci, associate professor}
 \authorIIIinfo{сand. of Comp.Sci, associate professor of Higher School of Software Engineering, Institute of Computer Science and Cybersecurity, Peter the Great St.\,Petersburg Polytechnic University}
 
 
 %\affiliation{1}{СПбПУ, Санкт-Петербургский политехнический университет Петра Великого, ул. Политехническая, дом 29, Санкт-Петербург, 195251, Россия}
 
        \affiliation{1}{SPbPU, Peter the Great St.\,Petersburg Polytechnic University, Politekhnicheskaya str., house 29, Saint-Petersburg, 195251, Russia}
        %даем команду на печать английского заголовка
        \maketranslatedtitle

        \begin{abstract} % all methods are famous and without articles
            Cogger and Yu method for evaluation weights and ranking alternatives is considered. Based on this pairwise comparison method, an open source decision support system is developed. The architecture of the developed application is presented, unit tests are conducted, including examples from publications and specially generated test cases. An example by V.V. Podinovsky, illustrating the incorrectness of hierarchy analysis method, showed, from our point of view, an acceptable result by Cogger and Yu method. The experiment is confirmed on a new original problem, showing the closeness of the results of Cogger and Yu method and criteria importance theory. The problem of ranking level generation algorithms for computer games in two-dimensional space is solved.

            \keywords multicriteria decision-making problems, paired comparisons, Cogger and Yu method, criteria importance theory, DASS, SVIR.
            \autocitationexample
            %\citationexample ???
            \acknowledgements 
            The paper authors are grateful to the DSS SVIR team of developers under the leadership of Professor S.V. Mikoni for providing the opportunity to solve problems in the system, as well as to the DSS DASS team of developers of under the leadership of Professor V.V. Podinovsky for making the system installer freely available.
        \end{abstract}

        \begin{thebibliography}{99}
\bibitem{Krivulin2015}{\it Krivulin, N.} Rating alternatives from pairwise comparisons by solving tropical optimization problems. In 2015 12th International Conference on Fuzzy Systems and Knowledge Discovery (FSKD). IEEE, 2015. P. 162-167. DOI:10.1109/FSKD.2015.7381933. URL:\url{https://ieeexplore.ieee.org/document/7381933}
\bibitem{Mikoni2022-en}{\it Mikoni, S.V.} Theory of Management Decision-Making: a textbook. — SPb.: Lan Publishing House, 2022. — 384 p.
\bibitem{Petrovskiy2009}{\it Petrovsky, A.B.} Theory of Decision-Making: a textbook for universities. — M.: Academy Publishing Center, 2009. — 400 p.
\bibitem{Podinovskiy2022}{\it Podinovsky, V.V.} Multicriteria Decision-Making Problems: Theory and Methods of Analysis: a textbook for universities. — M.: Yurait Publishing House, 2025. — 486 p.
\bibitem{Chern2012}{\it Chernorutsky, I.G.} — Methods of Decision-Making [Electronic resource]: a textbook; Saint Petersburg State Polytechnical University. — SPb., 2012. — Access mode:\url{http://elib.spbstu.ru/dl/2358.pdf}.
\bibitem{CoggerYu1985} {\it Cogger K. O., Yu P. L.} Eigenweight vectors and least-distance approximation for revealed preference in pairwise weight ratios //Journal of optimization theory and applications. – 1985. – Vol. 46. – PP. 483-491.
\bibitem{Saaty1977}{\it Saaty T. L.} A scaling method for priorities in hierarchical structures //Journal of mathematical psychology. – 1977. – Vol. 15. – N. 3. – PP. 234-281.    	
\bibitem{Superdecisions-en} Superdecisions DSS [Electronic resource] Access mode: \url{https://www.superdecisions.com/}
\bibitem{Salimgareev2023-en} {\it Salimgareev I.A.} AHP [Electronic resource] Access mode: URL: \url{https://github.com/DM-app-tools/AHP}
\bibitem{ParkhLaz2024-en} {\it Parkhomenko V.A., Lazarenko A.A.} Ranking support system using the Cogger and Yu method [Electronic resource] Access mode: \url{https://github.com/DM-app-tools/CoggerYuDecisionHelper}
\bibitem{Podinovskiy2011-en} {\it Podinovsky, V.V., Podinovskaya O.V.} On the incorrectness of the method hierarchy process analysis // Problems of Control Sciences. - 2011. - No. 1. - P. 8-13.
\bibitem{Krivulin2024-en} {\it Krivulin N.K. et al.} Solution of multicriteria problems of alternatives evaluation based on paired comparisons // Computer tools in education. - 2024. - No. 2. - P. 5-29.
\bibitem{Svir} SVIR' DSS [Electronic resource] Access mode: \url{http://www.mcd-svir.ru/}
\bibitem{Mikoni2001-en} {\it Mikoni S.V.} SVIR' selection and ranking system // Proceedings of the international congress "Artificial Intelligence in the 21st century". Divnomorskoye 3-8.09.2001. M.: Fizmatgiz, 2001. Vol. 1. P.500-507.
\bibitem{Mikoni2009-en} {\it Mikoni, S. V. Burakov, D. P. Garina, M. I.} Instrumental system for selecting multi-criteria choice problems // Software products and systems: scientific and scientific-practical ed. - Tver, 2009. - No. 4 (88). - P. 6-9 .
\bibitem{DASS} DASS DSS [Electronic resource] Access mode: \url{http://mcodm.ru/soft/dass/}
\bibitem{Podinovskiy2007-en} {\it Podinovsky V.V., Potapov M.A.} Theoretical foundations and systems for supporting multicriteria decisions // Proceedings of the XXXIV International Conference "Information Technologies in Science, Education, Telecommunications and Business" (May 20-30, 2007, Gurzuf, Ukraine). Supplement to the journal "Open Education". 2007. P. 87-89.
\bibitem{Podinovskiy2008-en} {\it Podinovsky, V.V.} Analysis of multicriteria choice problems by methods of the theory of criteria importance using computer systems for supporting decision making / V.V. Podinovsky // Bulletin of the Russian Academy of Sciences. Theory and Control Systems. – 2008. – No. 2. – P. 64-68. – EDN IJKDPT.
\bibitem{Chern2019-en} {\it Sokolova O. A., Chernorutsky I. G.} Software implementation of a dialog system for selecting options based on the Cogger and Yu method // SPbPU Science Week. – 2019. – P. 64-67.
\bibitem{Archimate-en} Archimate formalization tool [Electronic resource] Access mode: \url{https://www.archimatetool.com/}
\bibitem{Moreno2022} {\it Moreno-Armendáriz M. A. et al.} IORand: A Procedural Videogame Level Generator Based on a Hybrid PCG Algorithm //Applied Sciences. – 2022. – Т. 12. – №. 8. – С. 3792.
\bibitem{Kim2020} {\it Kim H. et al.} Graph based wave function collapse algorithm for procedural content generation in games //IEICE TRANSACTIONS on Information and Sys-tems. – 2020. – Т. 103. – №. 8. – С. 1901-1910.
\bibitem{Bagus2022} {\it Bagus Harisa A., Tai W. K.} Pacing-based Procedural Dungeon Level Genera-tion: Alternating Level Creation to Meet Designer’s Expectations //International Journal of Computing and Digital Systems. – 2022. – Т. 12. – №. 1. – С. 401-416.
\bibitem{Petrovas2022} {\it Petrovas A., Bausys R.} Procedural video game scene generation by genetic and neutrosophic WASPAS algorithms //Applied Sciences. – 2022. – Т. 12. – №. 2. – С. 772.
\bibitem{Gravina2019} {\it Gravina D. et al.} Procedural content generation through quality diversity //2019 IEEE Conference on Games (CoG). – IEEE, 2019. – С. 1-8.
\bibitem{Gellel2020} {\it Gellel A., Sweetser P.} A hybrid approach to procedural generation of roguelike video game levels //Proceedings of the 15th International Conference on the Foundations of Digital Games. – 2020. – С. 1-10.
\bibitem{Pontes2022} {\it De Pontes R. G., Gomes H. M., Seabra I. S. R.} Particle swarm optimization for procedural content generation in an endless platform game //Entertainment Computing. – 2022. – Т. 43. – С. 100496.        	
%            \bibitem{en-lib-1} {\it Madhav S.} Game Programming Algorithms and Techniques: A Platform-Agnostic Approach (Game Design). UK, 2013.
%            \bibitem{en-lib-2} {\it Ericson C.} Real-Time Collision Detection. USA, 2004.
        \end{thebibliography}

        \additionalinfo{Received October 7, 2001, The final version: December 28, 2015}
    \end{translatedpart}



%\bibliography{KoggerYu2023}


%% оформление
%    Ссылка на рис.~\ref{fig-example}
%    \begin{figure}[htb]
	%        \centering
	%        \includegraphics[width=0.4\textwidth]{xkcd1301.png}
	%        \caption{Достоверность информации в зависимости от расширения файла} \label{fig-example}
	%    \end{figure}

%Пример таблицы. [H] означает, что таблица должна быть ровно здесь и никуда не перемещаться.
%    \begin{table}[H]
	%        \centering
	%        \caption{Пример таблицы}
	%        \label{table-example}
	%        \small
	%        \begin{tabular}{|p{5cm}|c|}
		%            \hline
		%            \centering
		%            Вопрос & ? \\
		%            \hline
		%            Ответ & 42 \\
		%            \hline
		%        \end{tabular}
	%    \end{table}

% Мы можем ссылаться либо на рисунок полностью, например,~\ref{fig-example-2}, либо на подрисунки, например,~\ref{fig-example-2b}.
%\usepackage{subcaption}
%    \begin{figure}[H]
	%        \centering
	%        \begin{subfigure}[t]{70mm} %указываем размер подрисунка, без буквы [t] картинки будут вертикально отцентрованы
		%            \includegraphics[width=\textwidth]{xkcd1301.png} %width=\textwidth указывает, что ширина совпадает с шириной подрисунка
		%            \subcaption{Необязательный подзаголовок}
		%            \label{fig-example-2a}
		%        \end{subfigure}
	%        \quad %это широкий пробел между двумя рисунками
	%        \begin{subfigure}[t]{50mm}
		%            \includegraphics[width=\textwidth]{xkcd1301.png}
		%            \subcaption{} % Здесь подзаголовок не указан
		%            \label{fig-example-2b}
		%        \end{subfigure}
	%        \caption{Пример двух изображений рядом на одном рисунке} \label{fig-example-2}
	%    \end{figure}


\end{document}
